<!doctype html>
<html lang="fi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Idle Clicker</title>
  <style>
    :root { --radius: 14px; }

    body {
      font-family: system-ui, Arial, sans-serif;
      max-width: 980px;
      margin: 40px auto;
      padding: 0 16px;
    }

    h1 { margin: 0 0 12px; }

    .card {
      border: 1px solid #ddd;
      border-radius: var(--radius);
      padding: 16px;
      margin: 12px 0;
      background: #fff;
    }

    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    .big { font-size: 22px; font-weight: 900; }
    .muted { color: #666; }
    .small { font-size: 13px; }
    code { background: #f6f6f6; padding: 2px 6px; border-radius: 6px; }

    button {
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid #ccc;
      cursor: pointer;
      background: #fff;
      font-weight: 700;
    }
    button:disabled { opacity: .55; cursor: not-allowed; }

    .shopGrid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 12px;
    }

    .item {
      border: 1px solid #eee;
      border-radius: var(--radius);
      padding: 12px;
      display: grid;
      gap: 8px;
    }

    .itemTop {
      display:flex;
      justify-content: space-between;
      gap: 12px;
      align-items: baseline;
      flex-wrap: wrap;
    }

    .itemName { font-weight: 950; }

    .pillRow { display:flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .pill {
      border: 1px solid #ddd;
      border-radius: 999px;
      padding: 8px 12px;
      background: #fff;
      font-weight: 800;
    }
    .pill.active { border-color: #999; }

    .btnRow { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }

    hr { border: none; border-top: 1px solid #eee; margin: 12px 0; }

    /* Click pop */
    .popLayer { position: relative; }
    .pop {
      position: absolute;
      left: 10px;
      top: -6px;
      pointer-events: none;
      font-weight: 950;
      opacity: 0;
      transform: translateY(0);
      animation: popAnim 650ms ease-out forwards;
      white-space: nowrap;
    }
    @keyframes popAnim {
      0% { opacity: 0; transform: translateY(0); }
      10% { opacity: 1; }
      100% { opacity: 0; transform: translateY(-22px); }
    }

    /* Progress bar */
    .progressWrap { margin-top: 10px; }
    .progressBar {
      height: 10px;
      border-radius: 999px;
      background: #f2f2f2;
      border: 1px solid #e6e6e6;
      overflow: hidden;
    }
    .progressFill {
      height: 100%;
      width: 0%;
      background: #cfcfcf;
      transition: width 200ms linear;
    }

    /* Quest */
    .questChoice {
      border: 1px solid #eee;
      border-radius: 14px;
      padding: 12px;
      display: grid;
      gap: 10px;
      background: #fff;
    }
    .questTitle { font-weight: 900; }
    .questMeta { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .questTag { border:1px solid #ddd; border-radius:999px; padding:6px 10px; font-weight:800; }
    .questChoiceBtn { width: 100%; }

    /* ======= MOBIILI ======= */
    @media (max-width: 640px) {
      body { margin: 18px auto; padding: 0 12px; }
      .card { padding: 14px; }
      .big { font-size: 20px; }
      button { width: 100%; padding: 14px 14px; border-radius: 14px; }
      .row { align-items: stretch; }
      .pillRow { width: 100%; }
      .pill { width: auto; }
      .btnRow { align-items: stretch; }
      .itemTop { flex-direction: column; align-items: flex-start; }
      .popLayer { padding-bottom: 6px; }
    }
  </style>
</head>
<body>

<h1>Idle Clicker</h1>

<div class="card">
  <div class="big">Kolikot: <span id="coins">0</span></div>
  <div class="muted">
    Per klikki: <span id="perClick">1</span> |
    Per sekunti: <span id="perSec">0</span>
  </div>
</div>

<div class="card row">
  <button id="buyClickBtn">
    Osta Click Upgrade (+1)
    (hinta <span id="clickCost">25</span>)
  </button>
  <div class="muted">Ostettu: <span id="clickUps">0</span></div>
</div>

<div class="card row popLayer">
  <button id="clickBtn">Klikkaa +<span id="clickGain">1</span></button>
  <button id="saveBtn">Save</button>
  <button id="resetBtn">Reset</button>
  <div id="popContainer"></div>
</div>

<!-- QUEST v2 -->
<div class="card">
  <div class="big">Questi</div>
  <div id="questText" class="muted">-</div>

  <div class="progressWrap">
    <div class="progressBar"><div class="progressFill" id="questFill"></div></div>
    <div class="muted small" id="questHint">-</div>
  </div>

  <div class="row" style="margin-top:10px;">
    <button id="claimQuestBtn">Lunasta palkinto</button>
    <div class="muted small" id="questCooldown">-</div>
  </div>

  <div id="questChoicesWrap" style="margin-top:12px; display:grid; gap:10px;"></div>
</div>

<div class="card">
  <div class="big">Prestige: <span id="prestigePts">0</span> pts</div>
  <div class="muted">Kerroin: x<span id="prestigeMult">1.00</span></div>
  <button id="prestigeBtn">Prestige (saat <span id="prestigeGain">0</span>)</button>
  <div class="muted small" style="margin-top:8px;">
    Balanssi: saat prestige-pisteit√§ noin <b>5k</b> kolikon v√§lein (nousee hitaasti), ja jokainen piste antaa <b>+4%</b>.
  </div>
</div>

<div class="card">
  <div class="row" style="justify-content: space-between;">
    <div>
      <div class="big">Kauppa</div>
      <div class="muted">Osta tuottavia rakennuksia. Hinta kasvaa ostojen my√∂t√§.</div>
      <div class="muted small">Max-tilassa ‚ÄúOsta‚Äù k√§ytt√§√§ Smart Maxia (ostaa parasta arvoa).</div>
    </div>
    <div class="pillRow" aria-label="Ostomoodi">
      <button class="pill active" id="buyMode1">x1</button>
      <button class="pill" id="buyMode10">x10</button>
      <button class="pill" id="buyMode25">x25</button>
      <button class="pill" id="buyModeMax">Max</button>
    </div>
  </div>

  <div class="shopGrid" id="shopGrid"></div>
</div>

<div class="card">
  <div class="big">Tavoite</div>
  <div id="milestoneText" class="muted">-</div>

  <div class="progressWrap">
    <div class="progressBar"><div class="progressFill" id="milestoneFill"></div></div>
    <div class="muted small" id="milestoneHint">-</div>
  </div>

  <hr>
  <div class="big">Achievementit</div>
  <div id="achText" class="muted">-</div>
</div>

<div class="card muted">
  Offline-tuotto: <span id="offlineInfo">-</span>
</div>

<script>
(() => {
"use strict";

//// ======= PELIN TILA =======
let coins = 0;
let perClick = 1;

let clickUpgrades = 0;
let clickUpgradeCost = 25;

let prestigePoints = 0;

let buyMode = "x1"; // "x1" | "x10" | "x25" | "max"

let totalClicks = 0;
let lifetimeEarned = 0;

let achievements = {
  firstGenerator: false,
  tenTotalBuildings: false,
  hundredClicks: false,
  firstPrestige: false,
};
let lastAchMessage = "";

const SAVE_KEY = "idle_clicker_v07_questv2";

let autosaveId = null;
let idleTickId = null;
let uiTickId = null;

// ===== Balanssi =====
const PRICE_GROWTH = 1.14;

// Rakennukset
let buildings = [
  { id: "b1", name: "Klikkeri",      baseCost: 10,        baseCps: 1,        owned: 0 },
  { id: "b2", name: "Ty√∂paja",       baseCost: 120,       baseCps: 10,       owned: 0 },
  { id: "b3", name: "Tehdas",        baseCost: 1400,      baseCps: 80,       owned: 0 },
  { id: "b4", name: "Voimalaitos",   baseCost: 18000,     baseCps: 650,      owned: 0 },
  { id: "b5", name: "Megakompleksi", baseCost: 260000,    baseCps: 5200,     owned: 0 },
  { id: "b6", name: "Avaruusasema",  baseCost: 4000000,   baseCps: 42000,    owned: 0 },
];

//// ======= QUEST v2 (2 vaihtoehtoa) =======
const QUEST_COOLDOWN = 60 * 60; // 1h

// questState:
// {
//   active: Quest|null,
//   choices: [Quest, Quest] | null,
//   readyAt: number (unix sec)  // cooldown end timestamp, 0 if none
// }
let questState = {
  active: null,
  choices: null,
  readyAt: 0
};

function nowSec() { return Math.floor(Date.now() / 1000); }

function newQuestId() {
  return "q_" + nowSec() + "_" + Math.floor(Math.random() * 1e9);
}

//// ======= FORMAT =======
function fmt(n) {
  const x = Number(n);
  if (!Number.isFinite(x)) return "0";
  const abs = Math.abs(x);
  if (abs < 1000) return String(Math.floor(x));

  const units = [
    { v: 1e12, s: "T" },
    { v: 1e9,  s: "B" },
    { v: 1e6,  s: "M" },
    { v: 1e3,  s: "K" },
  ];
  for (const u of units) {
    if (abs >= u.v) {
      const val = x / u.v;
      const str = val >= 100 ? val.toFixed(0) : val >= 10 ? val.toFixed(1) : val.toFixed(2);
      return str.replace(/\.0+$/,"").replace(/(\.\d*[1-9])0+$/,"$1") + u.s;
    }
  }
  return String(Math.floor(x));
}

function fmtTime(secs) {
  const s = Math.max(0, Math.floor(secs));
  const h = Math.floor(s / 3600);
  const m = Math.floor((s % 3600) / 60);
  const r = s % 60;
  if (h > 0) return `${h}h ${m}m`;
  if (m > 0) return `${m}m ${r}s`;
  return `${r}s`;
}

//// ======= PRESTIGE =======
function getPrestigeMultiplier() {
  return 1 + prestigePoints * 0.04;
}
function calcPrestigeGain() {
  return Math.floor(Math.sqrt(coins / 5000));
}

//// ======= CPS + HINNAT =======
function calcPerSecond() {
  let cps = 0;
  for (const b of buildings) cps += b.owned * b.baseCps;
  return cps;
}

function costOfNext(b) {
  return Math.ceil(b.baseCost * Math.pow(PRICE_GROWTH, b.owned));
}

function costForN(b, n) {
  const start = b.baseCost * Math.pow(PRICE_GROWTH, b.owned);
  const total = start * (Math.pow(PRICE_GROWTH, n) - 1) / (PRICE_GROWTH - 1);
  return Math.ceil(total);
}

//// ======= SMART MAX BUY (EI J√Ñ√ÑDY) =======
function bestValueBuilding() {
  let best = null;
  let bestScore = -Infinity;
  for (const b of buildings) {
    const c = costOfNext(b);
    if (c <= 0) continue;
    const score = b.baseCps / c;
    if (score > bestScore) {
      bestScore = score;
      best = b;
    }
  }
  return best;
}

function smartMaxBuy() {
  let safety = 600;
  while (safety-- > 0) {
    const b = bestValueBuilding();
    if (!b) break;
    const c = costOfNext(b);
    if (coins < c) break;
    coins -= c;
    b.owned += 1;
  }
  markDirty();
}

//// ======= ACHIEVEMENTIT + MILESTONE =======
function totalBuildingsOwned() {
  return buildings.reduce((sum, b) => sum + b.owned, 0);
}

function awardAchievement(key, message, rewardFn) {
  if (achievements[key]) return false;
  achievements[key] = true;
  if (typeof rewardFn === "function") rewardFn();
  lastAchMessage = message;
  return true;
}

function checkAchievements() {
  if (totalBuildingsOwned() >= 1) {
    awardAchievement("firstGenerator", "üèÜ Ensimm√§inen rakennus! +25 kolikkoa", () => addCoins(25, "normal"));
  }

  if (totalBuildingsOwned() >= 10) {
    awardAchievement("tenTotalBuildings", "üèÜ 10 rakennusta! Click Upgrade -hinta -10% (kerran)", () => {
      clickUpgradeCost = Math.ceil(clickUpgradeCost * 0.9);
      markDirty();
    });
  }

  if (totalClicks >= 100) {
    awardAchievement("hundredClicks", "üèÜ 100 klikki√§! +1 perClick", () => {
      perClick += 1;
      markDirty();
    });
  }

  if (prestigePoints >= 1) {
    awardAchievement("firstPrestige", "üèÜ Ensimm√§inen prestige! +5% offline-cap (12h ‚Üí 12.6h)", () => {});
  }
}

function getMilestone() {
  const b2 = buildings.find(b => b.id === "b2");
  const b3 = buildings.find(b => b.id === "b3");
  const b4 = buildings.find(b => b.id === "b4");
  const b6 = buildings.find(b => b.id === "b6");

  if (b2.owned < 10) return { text: `Osta 10 Ty√∂pajaa (nyt ${b2.owned}/10)`, cur: b2.owned, goal: 10, hint: "Ty√∂paja on ensimm√§inen iso /s hyppy." };
  if (b3.owned < 10) return { text: `Osta 10 Tehdasta (nyt ${b3.owned}/10)`, cur: b3.owned, goal: 10, hint: "Tehdas vie sinut kunnolla idleen." };
  if (b4.owned < 5)  return { text: `Osta 5 Voimalaitosta (nyt ${b4.owned}/5)`, cur: b4.owned, goal: 5, hint: "Voimalaitos tekee prestigesta helpompaa." };
  if (b6.owned < 1)  return { text: `Osta 1 Avaruusasema (nyt ${b6.owned}/1)`, cur: b6.owned, goal: 1, hint: "T√§m√§ on version ‚Äúbossi‚Äù." };

  return { text: "Olet saavuttanut t√§m√§n version tavoitteet. Lis√§√§ pian lis√§√§!", cur: 1, goal: 1, hint: "Seuraavaksi: lis√§√§ achievementteja & rakennuksia." };
}

//// ======= RAHALIIKENNE =======
function addCoins(amount, source = "normal") {
  if (!Number.isFinite(amount) || amount === 0) return;
  coins += amount;
  if (amount > 0 && source !== "questReward") lifetimeEarned += amount;
  markDirty();
}

function spendCoins(amount) {
  if (!Number.isFinite(amount) || amount <= 0) return false;
  if (coins < amount) return false;
  coins -= amount;
  markDirty();
  return true;
}

//// ======= QUEST v2: GENEROINTI/PROGRESS =======
function makeBaseline() {
  return {
    clicks: totalClicks,
    earned: lifetimeEarned,
    buildings: totalBuildingsOwned(),
    ownedById: Object.fromEntries(buildings.map(b => [b.id, b.owned])),
  };
}

function createQuestTemplate(type, title, target, rewardCoins, rewardSeconds, extra = {}) {
  return {
    id: newQuestId(),
    type,
    title,
    target,
    baseline: makeBaseline(),
    rewardCoins,
    rewardSeconds,
    readyAt: 0,
    ...extra
  };
}

function generateOneQuest() {
  const curCps = Math.max(1, calcPerSecond());
  const r = Math.random();

  const baseRewardCoins = Math.ceil(curCps * 600); // ~10 min cps
  const baseRewardSeconds = 300;                   // 5 min instant

  if (r < 0.28) {
    const target = Math.max(50, Math.min(900, Math.ceil(120 + Math.sqrt(curCps) * 40)));
    return createQuestTemplate(
      "click",
      `Klikkaa ${target} kertaa`,
      target,
      baseRewardCoins,
      baseRewardSeconds
    );
  }

  if (r < 0.56) {
    const target = Math.max(1000, Math.min(3000000, Math.ceil(curCps * 180))); // ~3 min cps ansaintaa
    return createQuestTemplate(
      "earn",
      `Ansaitse ${fmt(target)} kolikkoa`,
      target,
      Math.ceil(baseRewardCoins * 1.05),
      baseRewardSeconds
    );
  }

  if (r < 0.80) {
    const target = Math.max(3, Math.min(60, Math.ceil(6 + Math.log10(curCps + 10) * 6)));
    return createQuestTemplate(
      "buyAny",
      `Osta ${target} rakennusta`,
      target,
      Math.ceil(baseRewardCoins * 1.1),
      baseRewardSeconds
    );
  }

  // buy specific (ei b1)
  const candidates = buildings.slice(1);
  const pick = candidates[Math.floor(Math.random() * candidates.length)];
  const target = Math.max(1, Math.min(12, Math.ceil(2 + Math.log10(curCps + 10) * 1.5)));

  return createQuestTemplate(
    "buySpecific",
    `Osta ${target} √ó ${pick.name}`,
    target,
    Math.ceil(baseRewardCoins * 1.15),
    baseRewardSeconds,
    { targetBuildingId: pick.id }
  );
}

function ensureQuestChoices() {
  // jos cooldown p√§√§ll√§, ei valintoja
  if (questState.readyAt > 0) return;
  if (questState.active) return;
  if (Array.isArray(questState.choices) && questState.choices.length === 2) return;

  // generoidaan 2 erilaista
  let a = generateOneQuest();
  let b = generateOneQuest();

  // yritet√§√§n v√§ltt√§√§ t√§ysin sama type+target, mutta pidet√§√§n yksinkertaisena
  let guard = 20;
  while (guard-- > 0 && (b.type === a.type && b.title === a.title)) {
    b = generateOneQuest();
  }

  questState.choices = [a, b];
  markDirty();
}

function activeQuestProgress(q) {
  if (!q) return 0;
  if (q.type === "click") return Math.max(0, totalClicks - q.baseline.clicks);
  if (q.type === "earn") return Math.max(0, Math.floor(lifetimeEarned - q.baseline.earned));
  if (q.type === "buyAny") return Math.max(0, totalBuildingsOwned() - q.baseline.buildings);
  if (q.type === "buySpecific") {
    const b = buildings.find(x => x.id === q.targetBuildingId);
    const owned = b ? b.owned : 0;
    const baseOwned = q.baseline.ownedById[q.targetBuildingId] ?? 0;
    return Math.max(0, owned - baseOwned);
  }
  return 0;
}

function canClaimActiveQuest() {
  const q = questState.active;
  if (!q) return false;
  if (questState.readyAt > 0) return false;
  return activeQuestProgress(q) >= q.target;
}

function chooseQuest(choiceId) {
  if (!questState.choices || questState.readyAt > 0 || questState.active) return;
  const picked = questState.choices.find(q => q.id === choiceId);
  if (!picked) return;

  questState.active = picked;
  questState.choices = null;
  markDirty();
}

function claimActiveQuest() {
  if (!canClaimActiveQuest()) return;
  const q = questState.active;

  addCoins(q.rewardCoins, "questReward");
  addCoins(q.rewardSeconds * calcPerSecond() * getPrestigeMultiplier(), "questReward");

  questState.active = null;
  questState.choices = null;
  questState.readyAt = nowSec() + QUEST_COOLDOWN;

  markDirty();
}

function cooldownLeft() {
  if (!questState.readyAt) return 0;
  return Math.max(0, questState.readyAt - nowSec());
}

function maybeEndCooldown() {
  if (!questState.readyAt) return;
  if (cooldownLeft() === 0) {
    questState.readyAt = 0;
    questState.active = null;
    questState.choices = null;
    ensureQuestChoices();
    markDirty();
  }
}

//// ======= UI ELEMENTIT =======
const elCoins = document.getElementById("coins");
const elPerClick = document.getElementById("perClick");
const elPerSec = document.getElementById("perSec");

const elClickGain = document.getElementById("clickGain");
const elClickCost = document.getElementById("clickCost");
const elClickUps = document.getElementById("clickUps");

const elPrestigePts = document.getElementById("prestigePts");
const elPrestigeMult = document.getElementById("prestigeMult");
const elPrestigeGain = document.getElementById("prestigeGain");

const elOfflineInfo = document.getElementById("offlineInfo");

const elMilestoneText = document.getElementById("milestoneText");
const elMilestoneFill = document.getElementById("milestoneFill");
const elMilestoneHint = document.getElementById("milestoneHint");

const elAchText = document.getElementById("achText");

const clickBtn = document.getElementById("clickBtn");
const buyClickBtn = document.getElementById("buyClickBtn");
const saveBtn = document.getElementById("saveBtn");
const resetBtn = document.getElementById("resetBtn");
const prestigeBtn = document.getElementById("prestigeBtn");

const buyMode1 = document.getElementById("buyMode1");
const buyMode10 = document.getElementById("buyMode10");
const buyMode25 = document.getElementById("buyMode25");
const buyModeMax = document.getElementById("buyModeMax");

const shopGrid = document.getElementById("shopGrid");
const popContainer = document.getElementById("popContainer");

// quest ui
const elQuestText = document.getElementById("questText");
const elQuestFill = document.getElementById("questFill");
const elQuestHint = document.getElementById("questHint");
const elQuestCooldown = document.getElementById("questCooldown");
const claimQuestBtn = document.getElementById("claimQuestBtn");
const questChoicesWrap = document.getElementById("questChoicesWrap");

//// ======= POP EFFECT =======
function spawnPop(text) {
  const el = document.createElement("div");
  el.className = "pop";
  el.textContent = text;
  el.style.left = (10 + Math.floor(Math.random() * 120)) + "px";
  el.style.top = (-6 - Math.floor(Math.random() * 6)) + "px";
  popContainer.appendChild(el);
  setTimeout(() => el.remove(), 800);
}

//// ======= SHOP UI: BUILD ONCE =======
const shopRefs = new Map();

function buildShopOnce() {
  shopGrid.innerHTML = "";
  for (const b of buildings) {
    const wrap = document.createElement("div");
    wrap.className = "item";
    wrap.dataset.id = b.id;

    const top = document.createElement("div");
    top.className = "itemTop";

    const name = document.createElement("div");
    name.className = "itemName";
    name.textContent = b.name;

    const owned = document.createElement("div");
    owned.className = "muted";
    owned.innerHTML = `Omistat: <span class="owned">0</span>`;

    top.appendChild(name);
    top.appendChild(owned);

    const info = document.createElement("div");
    info.className = "muted";
    info.innerHTML = `Tuotto: +${fmt(b.baseCps)}/s per kpl`;

    const btnRow = document.createElement("div");
    btnRow.className = "btnRow";

    const buyBtn = document.createElement("button");
    buyBtn.className = "buyBtn";
    buyBtn.textContent = "Osta";
    buyBtn.addEventListener("click", () => buyBuilding(b.id));

    const costEl = document.createElement("span");
    costEl.className = "muted";
    costEl.innerHTML = `Hinta: <span class="cost">-</span>`;

    btnRow.appendChild(buyBtn);
    btnRow.appendChild(costEl);

    wrap.appendChild(top);
    wrap.appendChild(info);
    wrap.appendChild(btnRow);

    shopGrid.appendChild(wrap);

    shopRefs.set(b.id, {
      ownedEl: wrap.querySelector(".owned"),
      costEl: wrap.querySelector(".cost"),
      buyBtn,
    });
  }
}

function setBuyMode(mode) {
  buyMode = mode;
  buyMode1.classList.toggle("active", mode === "x1");
  buyMode10.classList.toggle("active", mode === "x10");
  buyMode25.classList.toggle("active", mode === "x25");
  buyModeMax.classList.toggle("active", mode === "max");
  markDirty();
}

//// ======= DIRTY UI THROTTLE =======
let uiDirty = true;
function markDirty() { uiDirty = true; }

//// ======= SHOP LOGIIKKA =======
function buyBuilding(id) {
  if (buyMode === "max") {
    smartMaxBuy();
    return;
  }

  const b = buildings.find(x => x.id === id);
  if (!b) return;

  let n = 1;
  if (buyMode === "x10") n = 10;
  if (buyMode === "x25") n = 25;

  const totalCost = costForN(b, n);
  if (!spendCoins(totalCost)) return;

  b.owned += n;
  markDirty();
}

//// ======= OFFLINE =======
function offlineCapSeconds() {
  const base = 12 * 60 * 60;
  return achievements.firstPrestige ? Math.floor(base * 1.05) : base;
}

function applyOfflineEarnings() {
  const raw = localStorage.getItem(SAVE_KEY);
  if (!raw) return;

  let d;
  try { d = JSON.parse(raw); } catch { return; }

  const secondsAway = Math.floor((Date.now() - Number(d.savedAt)) / 1000);
  if (!Number.isFinite(secondsAway) || secondsAway <= 0) return;

  const cap = Math.min(secondsAway, offlineCapSeconds());

  const savedBuildings = Array.isArray(d.buildings) ? d.buildings : [];
  let savedCps = 0;
  for (const b of buildings) {
    const sb = savedBuildings.find(x => x.id === b.id);
    const owned = sb ? (Number(sb.owned) || 0) : 0;
    savedCps += owned * b.baseCps;
  }

  const gained = cap * savedCps * getPrestigeMultiplier();
  addCoins(gained, "normal");

  elOfflineInfo.textContent = `poissa ${fmt(secondsAway)}s ‚Üí +${fmt(gained)} kolikkoa (cap ${fmt(cap)}s)`;
}

//// ======= QUEST UI RENDER (choices) =======
function renderQuestChoices() {
  questChoicesWrap.innerHTML = "";

  if (questState.readyAt > 0) return;
  if (questState.active) return;
  if (!Array.isArray(questState.choices) || questState.choices.length !== 2) return;

  const labels = ["Vaihtoehto A", "Vaihtoehto B"];

  questState.choices.forEach((q, idx) => {
    const box = document.createElement("div");
    box.className = "questChoice";

    const title = document.createElement("div");
    title.className = "questTitle";
    title.textContent = labels[idx] + ": " + q.title;

    const meta = document.createElement("div");
    meta.className = "questMeta";
    const tag = document.createElement("span");
    tag.className = "questTag";
    tag.textContent = `Palkinto +${fmt(q.rewardCoins)} +${fmt(q.rewardSeconds)}s`;
    meta.appendChild(tag);

    const btn = document.createElement("button");
    btn.className = "questChoiceBtn";
    btn.textContent = "Valitse t√§m√§";
    btn.addEventListener("click", () => chooseQuest(q.id));

    box.appendChild(title);
    box.appendChild(meta);
    box.appendChild(btn);

    questChoicesWrap.appendChild(box);
  });
}

//// ======= UI UPDATE =======
function updateUI() {
  if (!uiDirty) return;
  uiDirty = false;

  // quest cooldown logic
  maybeEndCooldown();
  ensureQuestChoices();

  checkAchievements();

  const perSecond = calcPerSecond();
  const mult = getPrestigeMultiplier();

  elCoins.textContent = fmt(coins);
  elPerClick.textContent = fmt(perClick);
  elPerSec.textContent = fmt(perSecond);

  elClickGain.textContent = fmt(perClick);
  elClickCost.textContent = fmt(clickUpgradeCost);
  elClickUps.textContent = fmt(clickUpgrades);
  buyClickBtn.disabled = coins < clickUpgradeCost;

  elPrestigePts.textContent = fmt(prestigePoints);
  elPrestigeMult.textContent = mult.toFixed(2);
  const pg = calcPrestigeGain();
  elPrestigeGain.textContent = fmt(pg);
  prestigeBtn.disabled = pg <= 0;

  // milestone
  const ms = getMilestone();
  elMilestoneText.textContent = ms.text;
  const mpct = Math.max(0, Math.min(100, (ms.goal > 0 ? (ms.cur / ms.goal) * 100 : 0)));
  elMilestoneFill.style.width = mpct.toFixed(1) + "%";
  elMilestoneHint.textContent = `${ms.cur}/${ms.goal} (${mpct.toFixed(0)}%) ‚Äî ${ms.hint}`;

  // achievements list
  const list = [];
  list.push(achievements.firstGenerator ? "‚úÖ Ensimm√§inen rakennus" : "‚¨ú Ensimm√§inen rakennus");
  list.push(achievements.tenTotalBuildings ? "‚úÖ 10 rakennusta" : "‚¨ú 10 rakennusta");
  list.push(achievements.hundredClicks ? "‚úÖ 100 klikki√§" : "‚¨ú 100 klikki√§");
  list.push(achievements.firstPrestige ? "‚úÖ Ensimm√§inen prestige" : "‚¨ú Ensimm√§inen prestige");
  elAchText.textContent = (lastAchMessage ? (lastAchMessage + " | ") : "") + list.join(" ‚Ä¢ ");

  // shop hinnat + disable
  const best = bestValueBuilding();
  for (const b of buildings) {
    const ref = shopRefs.get(b.id);
    if (!ref) continue;

    ref.ownedEl.textContent = fmt(b.owned);

    let showCost = 0;
    if (buyMode === "x1") showCost = costOfNext(b);
    else if (buyMode === "x10") showCost = costForN(b, 10);
    else if (buyMode === "x25") showCost = costForN(b, 25);
    else showCost = costOfNext(b);

    ref.costEl.textContent = fmt(showCost);

    let canBuy = false;
    if (buyMode === "x1") canBuy = coins >= costOfNext(b);
    else if (buyMode === "x10") canBuy = coins >= costForN(b, 10);
    else if (buyMode === "x25") canBuy = coins >= costForN(b, 25);
    else canBuy = !!best && coins >= costOfNext(best);

    ref.buyBtn.disabled = !canBuy;
  }

  // quest UI
  const left = cooldownLeft();

  if (questState.readyAt > 0) {
    elQuestText.textContent = "Cooldown k√§ynniss√§‚Ä¶";
    elQuestHint.textContent = `Uudet vaihtoehdot ${fmtTime(left)} p√§√§st√§`;
    elQuestFill.style.width = "0%";
    elQuestCooldown.textContent = `Cooldown: ${fmtTime(left)}`;
    claimQuestBtn.disabled = true;
    questChoicesWrap.innerHTML = "";
  } else if (!questState.active) {
    elQuestText.textContent = "Valitse yksi n√§ist√§ kahdesta:";
    elQuestHint.textContent = "Kun valitset, questi aktivoituu.";
    elQuestFill.style.width = "0%";
    elQuestCooldown.textContent = "Cooldown alkaa vasta kun lunastat";
    claimQuestBtn.disabled = true;

    renderQuestChoices();
  } else {
    const q = questState.active;
    const p = activeQuestProgress(q);
    const pct = Math.max(0, Math.min(100, (q.target > 0 ? (p / q.target) * 100 : 0)));

    elQuestText.textContent = `${q.title} (${fmt(p)}/${fmt(q.target)})`;
    elQuestFill.style.width = pct.toFixed(1) + "%";
    elQuestHint.textContent = `Palkinto: +${fmt(q.rewardCoins)} kolikkoa +${fmt(q.rewardSeconds)}s tuotot heti`;
    elQuestCooldown.textContent = "Lunasta kun valmis";
    claimQuestBtn.disabled = !canClaimActiveQuest();
    questChoicesWrap.innerHTML = "";
  }
}

//// ======= SAVE / LOAD =======
function saveGame() {
  localStorage.setItem(SAVE_KEY, JSON.stringify({
    coins,
    perClick,
    clickUpgrades,
    clickUpgradeCost,
    prestigePoints,
    buildings: buildings.map(b => ({ id: b.id, owned: b.owned })),
    totalClicks,
    lifetimeEarned,
    achievements,
    buyMode,
    questState,
    savedAt: Date.now()
  }));
}

function loadGame() {
  const raw = localStorage.getItem(SAVE_KEY);
  if (!raw) return;

  try {
    const d = JSON.parse(raw);

    coins = Number(d.coins) || 0;
    perClick = Number(d.perClick) || 1;

    clickUpgrades = Number(d.clickUpgrades) || 0;
    clickUpgradeCost = Number(d.clickUpgradeCost) || 25;

    prestigePoints = Number(d.prestigePoints) || 0;

    totalClicks = Number(d.totalClicks) || 0;
    lifetimeEarned = Number(d.lifetimeEarned) || 0;

    if (d.achievements) achievements = { ...achievements, ...d.achievements };

    if (d.buyMode === "x1" || d.buyMode === "x10" || d.buyMode === "x25" || d.buyMode === "max") {
      buyMode = d.buyMode;
    }

    if (Array.isArray(d.buildings)) {
      for (const b of buildings) {
        const saved = d.buildings.find(x => x.id === b.id);
        if (saved) b.owned = Number(saved.owned) || 0;
      }
    }

    if (d.questState && typeof d.questState === "object") {
      questState = {
        active: d.questState.active || null,
        choices: Array.isArray(d.questState.choices) ? d.questState.choices : null,
        readyAt: Number(d.questState.readyAt) || 0
      };
    }
  } catch {
    localStorage.removeItem(SAVE_KEY);
  }
}

//// ======= EVENTIT =======
clickBtn.onclick = () => {
  totalClicks += 1;
  const gain = perClick * getPrestigeMultiplier();
  addCoins(gain, "normal");
  spawnPop("+" + fmt(gain));
};

buyClickBtn.onclick = () => {
  if (coins < clickUpgradeCost) return;
  if (!spendCoins(clickUpgradeCost)) return;

  clickUpgrades++;
  perClick++;
  clickUpgradeCost = Math.ceil(clickUpgradeCost * 1.23);
  markDirty();
};

prestigeBtn.onclick = () => {
  const gain = calcPrestigeGain();
  if (gain <= 0) return;

  prestigePoints += gain;

  coins = 0;
  perClick = 1;
  clickUpgrades = 0;
  clickUpgradeCost = 25;
  totalClicks = 0;
  for (const b of buildings) b.owned = 0;

  elOfflineInfo.textContent = "-";
  lastAchMessage = "";

  // quest reset: uusi valinta heti
  questState.active = null;
  questState.choices = null;
  questState.readyAt = 0;

  saveGame();
  markDirty();
};

claimQuestBtn.onclick = () => {
  claimActiveQuest();
};

saveBtn.onclick = () => saveGame();

resetBtn.onclick = () => {
  localStorage.removeItem(SAVE_KEY);
  location.reload();
};

buyMode1.onclick  = () => setBuyMode("x1");
buyMode10.onclick = () => setBuyMode("x10");
buyMode25.onclick = () => setBuyMode("x25");
buyModeMax.onclick = () => setBuyMode("max");

//// ======= AJASTIMET (EI J√Ñ√ÑDY) =======
function startTimers() {
  if (idleTickId) clearInterval(idleTickId);
  if (autosaveId) clearInterval(autosaveId);
  if (uiTickId) clearInterval(uiTickId);

  idleTickId = setInterval(() => {
    const perSecond = calcPerSecond();
    const add = (perSecond * getPrestigeMultiplier()) / 10;
    if (add !== 0) addCoins(add, "normal");
  }, 100);

  uiTickId = setInterval(() => {
    markDirty(); // countdown p√§ivittyy
    updateUI();
  }, 200);

  autosaveId = setInterval(() => saveGame(), 10000);
}

//// ======= START =======
buildShopOnce();
loadGame();
applyOfflineEarnings();
ensureQuestChoices();
setBuyMode(buyMode);
markDirty();
updateUI();
startTimers();

})();
</script>

</body>
</html>
